const g="VaultManagerDB",l="vaults",u="vaultNames";function v(){return new Promise((e,o)=>{const r=indexedDB.open(g,1);r.onerror=()=>o(r.error),r.onsuccess=()=>e(r.result),r.onupgradeneeded=n=>{const t=n.target.result;t.objectStoreNames.contains(l)||t.createObjectStore(l,{keyPath:"name"}).createIndex("name","name",{unique:!0}),t.objectStoreNames.contains(u)||t.createObjectStore(u,{keyPath:"name"})}})}async function s(e,o,r){const t=(await v()).transaction([e],o),a=t.objectStore(e);return new Promise((c,d)=>{let i;t.oncomplete=()=>c(i),t.onerror=()=>d(t.error),r(a).then(w=>i=w).catch(d)})}const m={async getVaultNames(){try{return console.log("IndexedDB: Getting vault names"),await s(u,"readonly",async e=>{const o=e.getAll();return new Promise((r,n)=>{o.onsuccess=()=>r(o.result.map(t=>t.name)),o.onerror=()=>n(o.error)})})}catch(e){throw console.error("IndexedDB Error getting vault names:",e),new Error(`Failed to get vault names from IndexedDB: ${e.message}`)}},async saveVaultNames(e){try{console.log("IndexedDB: Saving vault names:",e),await s(u,"readwrite",async o=>{const r=o.clear();await new Promise((n,t)=>{r.onsuccess=()=>n(),r.onerror=()=>t(r.error)});for(const n of e){const t=o.add({name:n});await new Promise((a,c)=>{t.onsuccess=()=>a(),t.onerror=()=>c(t.error)})}})}catch(o){throw console.error("IndexedDB Error saving vault names:",o),new Error(`Failed to save vault names to IndexedDB: ${o.message}`)}},async getVault(e){try{return console.log(`IndexedDB: Getting vault '${e}'`),await s(l,"readonly",async o=>{const r=o.get(e);return new Promise((n,t)=>{r.onsuccess=()=>{const a=r.result;n(a?a.data:null)},r.onerror=()=>t(r.error)})})}catch(o){throw console.error(`IndexedDB Error getting vault '${e}':`,o),new Error(`Failed to get vault '${e}' from IndexedDB: ${o.message}`)}},async saveVault(e,o){try{console.log(`IndexedDB: Saving vault '${e}'`),await s(l,"readwrite",async r=>{const n={name:e,data:o},t=r.put(n);await new Promise((a,c)=>{t.onsuccess=()=>a(),t.onerror=()=>c(t.error)})}),await s(u,"readwrite",async r=>{const n=r.put({name:e});await new Promise((t,a)=>{n.onsuccess=()=>t(),n.onerror=()=>a(n.error)})})}catch(r){throw console.error(`IndexedDB Error saving vault '${e}':`,r),new Error(`Failed to save vault '${e}' to IndexedDB: ${r.message}`)}},async deleteVault(e){try{console.log(`IndexedDB: Deleting vault '${e}'`),await s(l,"readwrite",async o=>{const r=o.delete(e);await new Promise((t,a)=>{r.onsuccess=()=>t(),r.onerror=()=>a(r.error)});const n=await this.getVaultNames();await this.saveVaultNames(n.filter(t=>t!==e))})}catch(o){throw console.error(`IndexedDB Error deleting vault '${e}':`,o),new Error(`Failed to delete vault '${e}' from IndexedDB: ${o.message}`)}}},D=m;export{D as dbService};
